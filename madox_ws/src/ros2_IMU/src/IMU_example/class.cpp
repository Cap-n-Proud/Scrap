#include <cstdio>

#include <iostream>
#include <chrono>
#include <RTIMULib.h>

using namespace std;

// https://github.com/kekiefer/ros2_rtimulib/blob/master/ros2_rtimulib/imu_node.py

class Room {
  // Access - Specifier

public:

  // Variable Declaration
  int lenght;
  int width;
  string name;
  int p;


  Room() {
    // init();
  }

  // int x = init2(this);

  int x = init3();
  int area(char *var1) {
    printf("Var %s p: %d\n", var1, p);
    return this->lenght * this->width;
  }

private:

  int init2(Room *r) {
    int max;

    max = 100; // set the upper bound to generate the random number
    srand(time(0));
    r->p = rand() % max;

    // printf("Var %d \n", p);
    return 0;
  }

  int init3() {
    int sampleCount = 0;
    int sampleRate  = 0;
    uint64_t rateTimer;
    uint64_t displayTimer;
    uint64_t now;

    //  Using RTIMULib here allows it to use the .ini file generated by
    // RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>",
    // "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be
    // loaded/saved

    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

    RTIMU *imu = RTIMU::createIMU(settings);

    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
      printf("No IMU found\n");
      exit(1);
    }

    //  This is an opportunity to manually override any settings before the call
    // IMUInit

    //  set up IMU

    imu->IMUInit();

    //  this is a convenient place to change fusion parameters

    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(true);

    //  set up for rate timer
    if (not self.pressure.pressureInit()):
              self.get_logger().info("Pressure sensor Init Failed")
          else:
              self.get_logger().info("Pressure sensor Init Succeeded")

    rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();

    while (1) {
      //  poll at the rate recommended by the IMU

      usleep(imu->IMUGetPollInterval() * 1000);

      while (imu->IMURead()) {
        RTIMU_DATA imuData = imu->getIMUData();

        //  add the pressure data to the structure


        sampleCount++;

        now = RTMath::currentUSecsSinceEpoch();

        //  display 10 times per second

        if ((now - displayTimer) > 10) {
          printf("Sample rate %d (cycle %d): %s\n", sampleRate,
                 (now - displayTimer) / 1000,
                 RTMath::displayDegrees("", imuData.fusionPose));


          fflush(stdout);
          displayTimer = now;
        }

        //  update rate every second

        if ((now - rateTimer) > 1000000) {
          sampleRate  = sampleCount;
          sampleCount = 0;
          rateTimer   = now;
        }
      }
    }

    // printf("Var %d \n", p);
    return 0;
  }

  // void read_IMU() {
  //   RTIMU_DATA imuData = imu->getIMUData();
  //
  //   printf("%s\r", RTMath::displayDegrees("", imuData.fusionPose));
  //   fflush(stdout);
  // }

  int init() {
    this->p = 100000;
    return 0;
  }
};


int main()
{
  Room bedroom;

  bedroom.name   = "bedroom";
  bedroom.lenght = 250;
  bedroom.width  = 400;
  printf("Lenght %d\n", bedroom.lenght);
  printf("Area %d\n",   bedroom.area("blah blah bah"));

  return 0;
}
